import{i as e}from"./utils-BniZYMK7.js";function getGlobal(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;if("undefined"!=typeof globalThis)return globalThis;throw new Error("unable to locate global object")}const t=getGlobal();"undefined"==typeof setTimeout&&e()&&(t.clearTimeout=function(e){e&&timer.stopTimer(e)},t.setTimeout=function(e,n){const r=timer.createTimer(n||1,Number.MAX_SAFE_INTEGER,(()=>{t.clearTimeout(r),e&&e()}),{});return r},t.clearImmediate=function(e){e&&timer.stopTimer(e)},t.setImmediate=function(e){const n=timer.createTimer(1,Number.MAX_SAFE_INTEGER,(()=>{t.clearImmediate(n),e&&e()}),{});return n},t.clearInterval=function(e){e&&timer.stopTimer(e)},t.setInterval=function(e,t){return timer.createTimer(1,t,(()=>{e&&e()}),{})});var n;"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */
n=()=>{function isFunction(e){return"function"==typeof e}let e;e=Array.isArray?Array.isArray:function(e){return"[object Array]"===Object.prototype.toString.call(e)};const t=e;let n,r,o=0,i=function asap(e,t){a[o]=e,a[o+1]=t,o+=2,2===o&&(r?r(flush):h())};const s="undefined"!=typeof window?window:void 0,u=s||{},l=u.MutationObserver||u.WebKitMutationObserver,c="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),f="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel;function useSetTimeout(){const e=setTimeout;return function(){return e(flush,1)}}var a=new Array(1e3);function flush(){for(let e=0;e<o;e+=2)(0,a[e])(a[e+1]),a[e]=void 0,a[e+1]=void 0;o=0}var h=void 0;function then(e,t){const n=this,r=new this.constructor(noop);void 0===r[p]&&makePromise(r);const{_state:o}=n;if(o){const e=arguments[o-1];i((()=>invokeCallback(o,r,e,n._result)))}else subscribe(n,r,e,t);return r}function resolve$1(e){if(e&&"object"==typeof e&&e.constructor===this)return e;const t=new this(noop);return resolve(t,e),t}h=c?function useNextTick(){return function(){return process.nextTick(flush)}}():l?function useMutationObserver(){let e=0;const t=new l(flush),n=document.createTextNode("");return t.observe(n,{characterData:!0}),function(){n.data=e=++e%2}}():f?function useMessageChannel(){const e=new MessageChannel;return e.port1.onmessage=flush,function(){return e.port2.postMessage(0)}}():void 0===s?function attemptVertx(){try{const e=Function("return this")().require("vertx");return n=e.runOnLoop||e.runOnContext,function useVertxTimer(){return void 0!==n?function(){n(flush)}:useSetTimeout()}()}catch(e){return useSetTimeout()}}():useSetTimeout();var p=Math.random().toString(36).substring(2);function noop(){}const m=void 0,d=1,_=2;function handleMaybeThenable(e,t,n){t.constructor===e.constructor&&n===then&&t.constructor.resolve===resolve$1?function handleOwnThenable(e,t){t._state===d?fulfill(e,t._result):t._state===_?reject(e,t._result):subscribe(t,void 0,(t=>resolve(e,t)),(t=>reject(e,t)))}(e,t):void 0===n?fulfill(e,t):isFunction(n)?function handleForeignThenable(e,t,n){i((e=>{let r=!1;const o=function tryThen(e,t,n,r){try{e.call(t,n,r)}catch(e){return e}}(n,t,(n=>{r||(r=!0,t!==n?resolve(e,n):fulfill(e,n))}),(t=>{r||(r=!0,reject(e,t))}),e._label);!r&&o&&(r=!0,reject(e,o))}),e)}(e,t,n):fulfill(e,t)}function resolve(e,t){if(e===t)reject(e,function selfFulfillment(){return new TypeError("You cannot resolve a promise with itself")}());else if(function objectOrFunction(e){const t=typeof e;return null!==e&&("object"===t||"function"===t)}(t)){let n;try{n=t.then}catch(t){return void reject(e,t)}handleMaybeThenable(e,t,n)}else fulfill(e,t)}function publishRejection(e){e._onerror&&e._onerror(e._result),publish(e)}function fulfill(e,t){e._state===m&&(e._result=t,e._state=d,0!==e._subscribers.length&&i(publish,e))}function reject(e,t){e._state===m&&(e._state=_,e._result=t,i(publishRejection,e))}function subscribe(e,t,n,r){const{_subscribers:o}=e,{length:s}=o;e._onerror=null,o[s]=t,o[s+d]=n,o[s+_]=r,0===s&&e._state&&i(publish,e)}function publish(e){const t=e._subscribers,n=e._state;if(0===t.length)return;let r,o;const i=e._result;for(let e=0;e<t.length;e+=3)r=t[e],o=t[e+n],r?invokeCallback(n,r,o,i):o(i);e._subscribers.length=0}function invokeCallback(e,t,n,r){const o=isFunction(n);let i,s,u=!0;if(o){try{i=n(r)}catch(e){u=!1,s=e}if(t===i)return void reject(t,function cannotReturnOwn(){return new TypeError("A promises callback cannot return that same promise.")}())}else i=r;t._state!==m||(o&&u?resolve(t,i):!1===u?reject(t,s):e===d?fulfill(t,i):e===_&&reject(t,i))}let b=0;function makePromise(e){e[p]=b++,e._state=void 0,e._result=void 0,e._subscribers=[]}const y=function(){function Enumerator(e,n){this._instanceConstructor=e,this.promise=new e(noop),this.promise[p]||makePromise(this.promise),t(n)?(this.length=n.length,this._remaining=n.length,this._result=new Array(this.length),0===this.length?fulfill(this.promise,this._result):(this.length=this.length||0,this._enumerate(n),0===this._remaining&&fulfill(this.promise,this._result))):reject(this.promise,function validationError(){return new Error("Array Methods must be provided an Array")}())}return Enumerator.prototype._enumerate=function _enumerate(e){for(let t=0;this._state===m&&t<e.length;t++)this._eachEntry(e[t],t)},Enumerator.prototype._eachEntry=function _eachEntry(e,t){const n=this._instanceConstructor,r=n.resolve;if(r===resolve$1){let r,o,i=!1;try{r=e.then}catch(e){i=!0,o=e}if(r===then&&e._state!==m)this._settledAt(e._state,t,e._result);else if("function"!=typeof r)this._remaining--,this._result[t]=e;else if(n===v){const s=new n(noop);i?reject(s,o):handleMaybeThenable(s,e,r),this._willSettleAt(s,t)}else this._willSettleAt(new n((t=>t(e))),t)}else this._willSettleAt(r(e),t)},Enumerator.prototype._settledAt=function _settledAt(e,t,n){const{promise:r}=this;r._state===m&&(this._remaining--,e===_?reject(r,n):this._result[t]=n),0===this._remaining&&fulfill(r,this._result)},Enumerator.prototype._willSettleAt=function _willSettleAt(e,t){const n=this;subscribe(e,void 0,(e=>n._settledAt(d,t,e)),(e=>n._settledAt(_,t,e)))},Enumerator}();var v=function(){function Promise(e){this[p]=function nextId(){return b++}(),this._result=this._state=void 0,this._subscribers=[],noop!==e&&("function"!=typeof e&&function needsResolver(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}(),this instanceof Promise?function initializePromise(e,t){try{t((function resolvePromise(t){resolve(e,t)}),(function rejectPromise(t){reject(e,t)}))}catch(t){reject(e,t)}}(this,e):function needsNew(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}())}return Promise.prototype.catch=function _catch(e){return this.then(null,e)},Promise.prototype.finally=function _finally(e){const t=this,{constructor:n}=t;return isFunction(e)?t.then((t=>n.resolve(e()).then((()=>t))),(t=>n.resolve(e()).then((()=>{throw t})))):t.then(e,e)},Promise}();return v.prototype.then=then,v.all=function all(e){return new y(this,e).promise},v.race=function race(e){const n=this;return t(e)?new n(((t,r)=>{const{length:o}=e;for(let i=0;i<o;i++)n.resolve(e[i]).then(t,r)})):new n(((e,t)=>t(new TypeError("You must pass an array to race."))))},v.resolve=resolve$1,v.reject=function reject$1(e){const t=new this(noop);return reject(t,e),t},v._setScheduler=function setScheduler(e){r=e},v._setAsap=function setAsap(e){i=e},v._asap=i,v.debug=function _debug(){return"[object ES6Promise]"},v.polyfill=function polyfill(){globalThis.Promise=v},v.Promise=v,v},globalThis.ES6Promise=n();const r=getGlobal();r.Buffer||("undefined"!=typeof Buffer?r.Buffer=Buffer:r.Buffer=DeviceRuntimeCore.Buffer),ES6Promise.polyfill(),Promise._setScheduler((e=>{e&&e()}));
