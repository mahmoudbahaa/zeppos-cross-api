var e;"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */
e=()=>{function isFunction(e){return"function"==typeof e}let e;e=Array.isArray?Array.isArray:function(e){return"[object Array]"===Object.prototype.toString.call(e)};const t=e;let n,r,o=0,s=function asap(e,t){f[o]=e,f[o+1]=t,o+=2,2===o&&(r?r(flush):h())};const i="undefined"!=typeof window?window:void 0,u=i||{},l=u.MutationObserver||u.WebKitMutationObserver,c="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),a="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel;function useSetTimeout(){const e=setTimeout;return function(){return e(flush,1)}}var f=new Array(1e3);function flush(){for(let e=0;e<o;e+=2)(0,f[e])(f[e+1]),f[e]=void 0,f[e+1]=void 0;o=0}var h=void 0;function then(e,t){const n=this,r=new this.constructor(noop);void 0===r[p]&&makePromise(r);const{_state:o}=n;if(o){const e=arguments[o-1];s((()=>invokeCallback(o,r,e,n._result)))}else subscribe(n,r,e,t);return r}function resolve$1(e){if(e&&"object"==typeof e&&e.constructor===this)return e;const t=new this(noop);return resolve(t,e),t}h=c?function useNextTick(){return function(){return process.nextTick(flush)}}():l?function useMutationObserver(){let e=0;const t=new l(flush),n=document.createTextNode("");return t.observe(n,{characterData:!0}),function(){n.data=e=++e%2}}():a?function useMessageChannel(){const e=new MessageChannel;return e.port1.onmessage=flush,function(){return e.port2.postMessage(0)}}():void 0===i?function attemptVertx(){try{const e=Function("return this")().require("vertx");return n=e.runOnLoop||e.runOnContext,function useVertxTimer(){return void 0!==n?function(){n(flush)}:useSetTimeout()}()}catch(e){return useSetTimeout()}}():useSetTimeout();var p=Math.random().toString(36).substring(2);function noop(){}const _=void 0,d=1,m=2;function handleMaybeThenable(e,t,n){t.constructor===e.constructor&&n===then&&t.constructor.resolve===resolve$1?function handleOwnThenable(e,t){t._state===d?fulfill(e,t._result):t._state===m?reject(e,t._result):subscribe(t,void 0,(t=>resolve(e,t)),(t=>reject(e,t)))}(e,t):void 0===n?fulfill(e,t):isFunction(n)?function handleForeignThenable(e,t,n){s((e=>{let r=!1;const o=function tryThen(e,t,n,r){try{e.call(t,n,r)}catch(e){return e}}(n,t,(n=>{r||(r=!0,t!==n?resolve(e,n):fulfill(e,n))}),(t=>{r||(r=!0,reject(e,t))}),e._label);!r&&o&&(r=!0,reject(e,o))}),e)}(e,t,n):fulfill(e,t)}function resolve(e,t){if(e===t)reject(e,function selfFulfillment(){return new TypeError("You cannot resolve a promise with itself")}());else if(function objectOrFunction(e){const t=typeof e;return null!==e&&("object"===t||"function"===t)}(t)){let n;try{n=t.then}catch(t){return void reject(e,t)}handleMaybeThenable(e,t,n)}else fulfill(e,t)}function publishRejection(e){e._onerror&&e._onerror(e._result),publish(e)}function fulfill(e,t){e._state===_&&(e._result=t,e._state=d,0!==e._subscribers.length&&s(publish,e))}function reject(e,t){e._state===_&&(e._state=m,e._result=t,s(publishRejection,e))}function subscribe(e,t,n,r){const{_subscribers:o}=e,{length:i}=o;e._onerror=null,o[i]=t,o[i+d]=n,o[i+m]=r,0===i&&e._state&&s(publish,e)}function publish(e){const t=e._subscribers,n=e._state;if(0===t.length)return;let r,o;const s=e._result;for(let e=0;e<t.length;e+=3)r=t[e],o=t[e+n],r?invokeCallback(n,r,o,s):o(s);e._subscribers.length=0}function invokeCallback(e,t,n,r){const o=isFunction(n);let s,i,u=!0;if(o){try{s=n(r)}catch(e){u=!1,i=e}if(t===s)return void reject(t,function cannotReturnOwn(){return new TypeError("A promises callback cannot return that same promise.")}())}else s=r;t._state!==_||(o&&u?resolve(t,s):!1===u?reject(t,i):e===d?fulfill(t,s):e===m&&reject(t,s))}let b=0;function makePromise(e){e[p]=b++,e._state=void 0,e._result=void 0,e._subscribers=[]}const y=function(){function Enumerator(e,n){this._instanceConstructor=e,this.promise=new e(noop),this.promise[p]||makePromise(this.promise),t(n)?(this.length=n.length,this._remaining=n.length,this._result=new Array(this.length),0===this.length?fulfill(this.promise,this._result):(this.length=this.length||0,this._enumerate(n),0===this._remaining&&fulfill(this.promise,this._result))):reject(this.promise,function validationError(){return new Error("Array Methods must be provided an Array")}())}return Enumerator.prototype._enumerate=function _enumerate(e){for(let t=0;this._state===_&&t<e.length;t++)this._eachEntry(e[t],t)},Enumerator.prototype._eachEntry=function _eachEntry(e,t){const n=this._instanceConstructor,r=n.resolve;if(r===resolve$1){let r,o,s=!1;try{r=e.then}catch(e){s=!0,o=e}if(r===then&&e._state!==_)this._settledAt(e._state,t,e._result);else if("function"!=typeof r)this._remaining--,this._result[t]=e;else if(n===v){const i=new n(noop);s?reject(i,o):handleMaybeThenable(i,e,r),this._willSettleAt(i,t)}else this._willSettleAt(new n((t=>t(e))),t)}else this._willSettleAt(r(e),t)},Enumerator.prototype._settledAt=function _settledAt(e,t,n){const{promise:r}=this;r._state===_&&(this._remaining--,e===m?reject(r,n):this._result[t]=n),0===this._remaining&&fulfill(r,this._result)},Enumerator.prototype._willSettleAt=function _willSettleAt(e,t){const n=this;subscribe(e,void 0,(e=>n._settledAt(d,t,e)),(e=>n._settledAt(m,t,e)))},Enumerator}();var v=function(){function Promise(e){this[p]=function nextId(){return b++}(),this._result=this._state=void 0,this._subscribers=[],noop!==e&&("function"!=typeof e&&function needsResolver(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}(),this instanceof Promise?function initializePromise(e,t){try{t((function resolvePromise(t){resolve(e,t)}),(function rejectPromise(t){reject(e,t)}))}catch(t){reject(e,t)}}(this,e):function needsNew(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}())}return Promise.prototype.catch=function _catch(e){return this.then(null,e)},Promise.prototype.finally=function _finally(e){const t=this,{constructor:n}=t;return isFunction(e)?t.then((t=>n.resolve(e()).then((()=>t))),(t=>n.resolve(e()).then((()=>{throw t})))):t.then(e,e)},Promise}();return v.prototype.then=then,v.all=function all(e){return new y(this,e).promise},v.race=function race(e){const n=this;return t(e)?new n(((t,r)=>{const{length:o}=e;for(let s=0;s<o;s++)n.resolve(e[s]).then(t,r)})):new n(((e,t)=>t(new TypeError("You must pass an array to race."))))},v.resolve=resolve$1,v.reject=function reject$1(e){const t=new this(noop);return reject(t,e),t},v._setScheduler=function setScheduler(e){r=e},v._setAsap=function setAsap(e){s=e},v._asap=s,v.debug=function _debug(){return"[object ES6Promise]"},v.polyfill=function polyfill(){globalThis.Promise=v},v.Promise=v,v},globalThis.ES6Promise=e(),ES6Promise.polyfill(),Promise._setScheduler((e=>{e&&e()}));
